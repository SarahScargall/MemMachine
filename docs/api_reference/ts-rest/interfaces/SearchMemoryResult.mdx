---
title: "Retrieving Memory"
description: "Search query configurations and the multi-layered memory result model."
---

## Interface `SearchMemoryOptions`

Fine-tune your semantic search by applying filters, thresholds, and specifying which memory types to scan.

| Property | Type | Description |
| :--- | :--- | :--- |
| **top_k** | `number` | *Optional.* Replaces `limit`. Maximum number of results to return. Defaults to `10`. |
| **filter** | `string` | *Optional.* Filter expression to narrow search results based on metadata. |
| **expand_context** | `number` | **New.** Number of extra episodes to include for context. Defaults to `0`. |
| **score_threshold** | `number` | **New.** Minimum relevance score required to include a memory. |
| **types** | `MemoryType[]` | *Optional.* Memory types to search. Defaults to `['episodic', 'semantic']`. |

---

## Interface `SearchMemoryResult`

The search response provides a structured view of retrieved information, categorized by memory "depth" and type.

| Property | Type | Description |
| :--- | :--- | :--- |
| `status` | `number` | The status code of the search operation. |
| `content` | `object` | The container for all retrieved memory data. |

### The `content` Object
The search engine returns a tiered memory structure:

**Episodic Memory (`content.episodic_memory`)**
* `short_term_memory`: Recent interactions as [`EpisodicMemory[]`](./EpisodicMemory).
* `long_term_memory`: Historical data as [`EpisodicMemory[]`](./EpisodicMemory).
* `episode_summary`: A list of strings summarizing the found episodes.

**Semantic Memory (`content.semantic_memory`)**
* Returns an array of [`SemanticMemory[]`](./EpisodicMemory) representing distilled knowledge.

---

## Usage Example

```typescript
import { MemMachineClient } from '@memmachine/client';

const memory = client.project({ org_id: 'org_1', project_id: 'proj_1' }).memory();

// Search with new parameters: top_k, filters, and score thresholds
const results = await memory.search("What were the client's requirements for the Q3 project?", {
  top_k: 5,
  score_threshold: 0.85,
  expand_context: 2,
  filter: "metadata.status = 'active' AND metadata.priority > 7",
  types: ['episodic', 'semantic']
});

if (result.status === 0) {
  const { short_term_memory } = result.content.episodic_memory
  console.log(`Context clues: ${short_term_memory.episodes.length}`)

  const knowledge = result.content.semantic_memory
  console.log(`Knowledge points: ${knowledge.length}`)
}
```

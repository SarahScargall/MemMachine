---
title: "Retrieving Memory"
description: "Search query configurations and the multi-layered memory result model."
---

## Interface `SearchMemoryOptions`

Fine-tune your semantic search by applying filters, thresholds, and specifying which memory types to scan.

| Property | Type | Description |
| :--- | :--- | :--- |
<<<<<<< Updated upstream
| `top_k` | `number` | *Optional.* The maximum number of results to return. Defaults to `10`. |
| `filter` | `string` | *Optional.* Filter expression to narrow search results based on metadata. |
| `expand_context` | `number` | *Optional.* Number of extra episodes to include for context. Defaults to `0`. |
| `score_threshold` | `number` | *Optional.* Minimum relevance score required to include a memory. |
| `types` | [`MemoryType[]`](./Types) | *Optional.* Search within `episodic`, `semantic`, or both. Defaults to both. |

---

## Filtering Guide

The `filter` parameter now accepts a string-based expression rather than a JSON object. This allows for complex logical combinations using metadata attributes.

### Syntax
Filters follow the pattern: `metadata.<key> <operator> <value>`

* **Operators:** `=`, `!=`, `>`, `<`, `>=`, `<=`
* **Logical Joins:** `AND`, `OR`
* **Values:** Strings must be enclosed in single quotes (`'`). Numbers and booleans are passed as-is.

### Examples
| Goal | Filter String |
| :--- | :--- |
| **Simple Match** | `metadata.user_id = 'alice'` |
| **Numerical Range** | `metadata.priority >= 5` |
| **Logical AND** | `metadata.category = 'finance' AND metadata.verified = true` |
| **Complex Logic** | `(metadata.source = 'email' OR metadata.source = 'slack') AND metadata.importance > 8` |
=======
| **top_k** | `number` | *Optional.* Replaces `limit`. Maximum number of results to return. Defaults to `10`. |
| **filter** | `string` | *Optional.* Filter expression to narrow search results based on metadata. |
| **expand_context** | `number` | **New.** Number of extra episodes to include for context. Defaults to `0`. |
| **score_threshold** | `number` | **New.** Minimum relevance score required to include a memory. |
| **types** | `MemoryType[]` | *Optional.* Memory types to search. Defaults to `['episodic', 'semantic']`. |
>>>>>>> Stashed changes

---

## Interface `SearchMemoryResult`

The search response provides a structured view of retrieved information, categorized by memory "depth" and type.

| Property | Type | Description |
| :--- | :--- | :--- |
| `status` | `number` | The status code of the search operation. |
| `content` | `object` | The container for all retrieved memory data. |

### The `content` Object
The search engine returns a tiered memory structure:

**Episodic Memory (`content.episodic_memory`)**
* `short_term_memory`: Recent interactions as [`EpisodicMemory[]`](./EpisodicMemory).
* `long_term_memory`: Historical data as [`EpisodicMemory[]`](./EpisodicMemory).
* `episode_summary`: A list of strings summarizing the found episodes.

**Semantic Memory (`content.semantic_memory`)**
* Returns an array of [`SemanticMemory[]`](./EpisodicMemory) representing distilled knowledge.

---

## Usage Example

```typescript
import { MemMachineClient } from '@memmachine/client';

const memory = client.project({ org_id: 'org_1', project_id: 'proj_1' }).memory();

// Search with new parameters: top_k, filters, and score thresholds
const results = await memory.search("What were the client's requirements for the Q3 project?", {
  top_k: 5,
  score_threshold: 0.85,
  expand_context: 2,
  filter: "metadata.status = 'active' AND metadata.priority > 7",
  types: ['episodic', 'semantic']
});

if (results.status === 200) {
  // Accessing episodic context
  const { short_term_memory } = results.content.episodic_memory;
  console.log(`Context clues: ${short_term_memory.length}`);
  
  // Accessing semantic knowledge
  const knowledge = results.content.semantic_memory;
  console.log(`Knowledge points: ${knowledge.length}`);
}